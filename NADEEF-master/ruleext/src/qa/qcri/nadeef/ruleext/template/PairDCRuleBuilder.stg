addPredicate(template) ::= <<
predicates.add(Predicate.valueOf("$template$", tableName)); $\n$
>>

dcTemplate(DCName, template, tableName) ::= <<
/*
 * Code Generated by NADEEF.
 */
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.HashMap;

import qa.qcri.nadeef.core.datamodel.Column;
import qa.qcri.nadeef.core.datamodel.Cell;
import qa.qcri.nadeef.core.datamodel.Operation;
import qa.qcri.nadeef.core.datamodel.Fix;
import qa.qcri.nadeef.core.datamodel.PairTupleRule;
import qa.qcri.nadeef.core.datamodel.Predicate;
import qa.qcri.nadeef.core.datamodel.Tuple;
import qa.qcri.nadeef.core.datamodel.TuplePair;
import qa.qcri.nadeef.core.datamodel.Violation;

public class $DCName$ extends PairTupleRule{
    private List<Predicate> predicates;

    public $DCName$() {
        String tableName = "$tableName$";
        predicates = new ArrayList<>();
        $template:addPredicate()$
    }

    @Override
    public Collection<Violation> detect(TuplePair tuplePair) {
        List<Violation> result = new ArrayList<>();
        Set<Cell> infectedCells;
        Tuple left = tuplePair.getLeft();
        Tuple right = tuplePair.getRight();

        infectedCells = isValid(left, right);

        // invert the order and try again
        if (infectedCells == null) {
            infectedCells = isValid(right, left);
        }

        // all the predicates are valid, then the DC is violated
        if (infectedCells != null) {
            Violation violation = new Violation(getRuleName());
            for (Cell cell : infectedCells) {
                violation.addCell(cell);
            }
            //violation.addCell(cell);
            result.add(violation);
        }

        return result;
    }

    @Override
    public Collection<Fix> repair(Violation violation) {
        List<Cell> cells = new ArrayList<>(violation.getCells());
        List<Fix> result = new ArrayList<>();
        HashMap<Column, List<Cell> > columnMap = new HashMap<>();

        Fix.Builder builder = new Fix.Builder(violation);
        for (Cell cell : cells) {
            Column column = cell.getColumn();
            List<Cell> cellSet = null;
            if (columnMap.containsKey(column)) {
                cellSet = columnMap.get(column);
            } else {
                cellSet = new ArrayList<>();
                columnMap.put(column, cellSet);
            }
            cellSet.add(cell);
        }

        for (Predicate predicate : predicates) {
            // TODO: we don't know how to solve NEQ problem.
            if (predicate.getOperation().equals(Operation.NEQ))
                continue;
            Column leftColumn = predicate.getLeft();
            if (predicate.isRightConstant()) {
                List<Cell> cellList = columnMap.get(leftColumn);
                for (Cell cell : cellList) {
                    result.add(builder
                        .left(cell)
                        .op(repairOperation(predicate.getOperation()))
                        .right(predicate.getValue())
                        .build()
                    );
                }
            } else {
                Column rightColumn = predicate.getRight();
                List<Cell> cellListLeft = columnMap.get(leftColumn);
                List<Cell> cellListRight = columnMap.get(rightColumn);
                // left, right columns are the same.
                // a potential bug when different predicates are mapping to the same column.
                // e.g. not(t1.b < t2.c && t1.b != 2), to solve it we need to do a sanity check
                // on the cells again!
                if (leftColumn.equals(rightColumn)) {
                    assert cellListLeft.size() > 1;
                    Cell c0 = cellListLeft.get(0);
                    Cell c1 = cellListLeft.get(1);

                    if (predicate.isValid(c0, c1))
                        result.add(
                            builder
                                .left(c0)
                                .op(repairOperation(predicate.getOperation()))
                                .right(c1)
                                .build());
                    else
                        result.add(
                            builder
                                .left(c1)
                                .op(repairOperation(predicate.getOperation()))
                                .right(c0)
                                .build());
                } else {
                    result.add(
                        builder
                        .left(cellListLeft.get(0))
                        .op(repairOperation(predicate.getOperation()))
                        .right(cellListRight.get(0))
                        .build()
                    );
                }

            }
        }
        return result;
    }

    private Operation repairOperation(Operation op) {
        Operation result = null;
        switch (op) {
            case EQ:
                result = Operation.NEQ;
                break;
            case GT:
                result = Operation.LTE;
                break;
            case GTE:
                result = Operation.LT;
                break;
            case LT:
                result = Operation.GTE;
                break;
            case LTE:
                result = Operation.GT;
                break;
            case NEQ:
                result = Operation.EQ;
                break;
            default:
                assert true : "unknown operations";
        }
        return result;
    }

    private Set<Cell> isValid(Tuple left, Tuple right) {
        Set<Cell> infectedCells = new HashSet<>();
        boolean isValid = true;
        for (Predicate predicate : predicates) {
            if (!predicate.isValid(left, right)) {
                isValid = false;
                break;
            }

            Cell leftCell = left.getCell(predicate.getLeft());
            infectedCells.add(leftCell);
            if (!predicate.isRightConstant()){
                Cell rightCell = right.getCell(predicate.getRight());
                infectedCells.add(rightCell);
            }
        }
        return isValid ? infectedCells : null;
    }
}
>>